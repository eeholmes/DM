% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/findOptimum.R
\name{findOptimum}
\alias{findOptimum}
\title{Optimization functions.}
\usage{
findOptimum(dat, input, silent = FALSE)
}
\arguments{
\item{dat}{data from the A & P file}

\item{input}{a list with the other values needed for a DM run.}

\item{silent}{(TRUE/FALSE)}
}
\value{
A list.  $estimate is the logged parameters at the minimum sum of squared residuals.  The parameters are log(prod), log(cap), log(msCoef), log(flowCoef).  $value is the sum of squared residuals at the minimum.
}
\description{
Because the likelihood surfaces for these problems often has 
a severe bananna shape with a poorly defined maximum finding 
an optimum is often non-trivial If an optimum is given in the 
input file I use that as an initial value for nlm otherwise, 
I found that nlm often gets stuck in a local min. So here I 
have iterated between a genetic optimization algorithm and nlm.  
This works more often but still at times misses the optimum. 
This is adhoc.
}
\details{
In SRFunctions(), bev-holt is defined as
S/(S*exp(-p[2])+exp(-p[1]))*exp(exp(p[3])*logMS)*exp(exp(p[4])*logFlow)
In DM (writeBUGSmodel.R), 
R = [S/( (S/exp(logCap)) + (1/prod)  )]  exp(marineInd*logMS)  exp(flowCoef*logFlow)
so
p[1] = log(prod),
p[2] = log(cap),
p[3] = log(msCoef),
p[4] = log(flowCoef)
}
